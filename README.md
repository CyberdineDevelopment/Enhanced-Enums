# FractalDataWorks Enhanced Enums

[![NuGet](https://img.shields.io/nuget/v/FractalDataWorks.EnhancedEnums.svg)](https://www.nuget.org/packages/FractalDataWorks.EnhancedEnums/)
[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](LICENSE)

A powerful source generator for creating type-safe, object-oriented enumerations in C# with zero boilerplate.

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Features](#features)
- [Advanced Usage](#advanced-usage)
- [Performance](#performance)
- [API Reference](#api-reference)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)

## Overview

Enhanced Enums transforms simple class hierarchies into powerful, type-safe enumerations with:

- **Static Factory Methods**: Access enum values with compile-time safety (e.g., `OrderStatuses.Pending()`)
- **Efficient Lookups**: O(1) dictionary-based lookups by name or custom properties
- **Rich Objects**: Enum values can have methods, properties, and complex behavior
- **Source Generation**: All code generated at compile-time with zero runtime overhead
- **Singleton Pattern**: Each enum value is instantiated once and reused

### How It Works

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant SG as Source Generator
    participant CC as C# Compiler
    participant App as Application

    Dev->>Dev: Write EnhancedEnum classes
    Note over Dev: [EnumCollection] on base<br/>[EnumOption] on values
    
    Dev->>CC: Compile project
    CC->>SG: Trigger source generator
    
    SG->>SG: Find [EnumCollection] types
    SG->>SG: Discover [EnumOption] types
    SG->>SG: Generate collection class
    Note over SG: Static constructor<br/>Lookup dictionaries<br/>Factory methods
    
    SG->>CC: Add generated source
    CC->>CC: Compile with generated code
    CC->>App: Output assembly
    
    App->>App: Static initialization
    Note over App: Create singletons<br/>Build lookup tables
    
    Dev->>App: Use enhanced enums
    Note over App: OrderStatuses.Pending()<br/>OrderStatuses.GetByName("Shipped")<br/>OrderStatuses.All
```

## Installation

```xml
<PackageReference Include="FractalDataWorks.EnhancedEnums" Version="*" />
<PackageReference Include="FractalDataWorks" Version="*" />
```

Both packages are required - `FractalDataWorks` provides the attributes and interfaces.

## Quick Start

### 1. Define Your Enhanced Enum

```csharp
using FractalDataWorks;

// Using built-in EnhancedEnumBase<T> which provides Id and Name
[EnumCollection]
public abstract class OrderStatus : EnhancedEnumBase<OrderStatus>
{
    public abstract bool CanCancel { get; }
    
    protected OrderStatus(int id, string name) : base(id, name) { }
}

[EnumOption]
public class Pending : OrderStatus
{
    public Pending() : base(1, "Pending") { }
    public override bool CanCancel => true;
}

[EnumOption]
public class Processing : OrderStatus
{
    public Processing() : base(2, "Processing") { }
    public override bool CanCancel => true;
}

[EnumOption]
public class Shipped : OrderStatus
{
    public Shipped() : base(3, "Shipped") { }
    public override bool CanCancel => false;
}
```

### 2. Use the Generated Collection

```csharp
// Access all values
foreach (var status in OrderStatuses.All)
{
    Console.WriteLine($"{status.Name}: Can Cancel = {status.CanCancel}");
}

// Factory methods (generated by default)
var pending = OrderStatuses.Pending();
var shipped = OrderStatuses.Shipped();

// Lookup by name
var status = OrderStatuses.GetByName("Processing");

// Safe lookup
if (OrderStatuses.TryGetByName("Unknown", out var found))
{
    // Handle found status
}

// Empty value pattern
var none = OrderStatuses.Empty; // Returns EmptyOrderStatus instance
```

## Features

### Base Class Pattern

Enhanced Enums provides a built-in `EnhancedEnumBase<T>` class that enforces the Id and Name pattern:

```csharp
// REQUIRED: All enhanced enums must inherit from EnhancedEnumBase<T>
[EnumCollection]
public abstract class Status : EnhancedEnumBase<Status>
{
    protected Status(int id, string name) : base(id, name) { }
}

// You can add additional properties to your base class
[EnumCollection]
public abstract class CustomBase : EnhancedEnumBase<CustomBase>
{
    public abstract string Code { get; }
    
    protected CustomBase(int id, string name) : base(id, name) { }
}
```

### Empty Value Pattern

Every generated collection includes an `Empty` property that returns a singleton empty/null instance:

```csharp
var empty = OrderStatuses.Empty; // Singleton instance
// Empty values:
// - Have Id = 0 and Name = "Empty"
// - Return default values for all methods
// - Return null/default for all properties
```

### Factory Method Control

Control factory method generation at multiple levels:

```csharp
// Collection level - affects all options
[EnumCollection(GenerateFactoryMethods = false)]
public abstract class Status : EnhancedEnumBase<Status> { }

// Option level - overrides collection setting
[EnumOption(GenerateFactoryMethod = false)]
public class SpecialStatus : Status { }
```

### Return Type Configuration

Specify custom return types for better API design:

```csharp
// For non-generic base types
[EnumCollection(ReturnType = "IOrderStatus")]
public abstract class OrderStatus : EnhancedEnumBase<OrderStatus>, IOrderStatus { }

// For generic base types
[EnumCollection(DefaultGenericReturnType = "IMessage")]
public abstract class Message<T> : EnhancedEnumBase<Message<T>>, IMessage { }
```

### Lookup Properties

Generate custom lookup methods for any property:

```csharp
[EnumCollection]
public abstract class Country : EnhancedEnumBase<Country>
{
    [EnumLookup]
    public abstract string IsoCode { get; }
    
    [EnumLookup(MethodName = "FindByCapital")]
    public abstract string Capital { get; }
    
    protected Country(int id, string name) : base(id, name) { }
}

// Generated methods:
var usa = Countries.GetByIsoCode("US");
var france = Countries.FindByCapital("Paris");
```

### Multiple Collections

Organize enum values into multiple collections:

```csharp
[EnumCollection("ActiveStatuses")]
[EnumCollection("InactiveStatuses")]
public abstract class Status : EnhancedEnumBase<Status>
{
    protected Status(int id, string name) : base(id, name) { }
}

[EnumOption(CollectionName = "ActiveStatuses")]
public class Running : Status
{
    public Running() : base(1, "Running") { }
}

[EnumOption(CollectionName = "InactiveStatuses")]
public class Stopped : Status
{
    public Stopped() : base(2, "Stopped") { }
}

// Usage:
var active = ActiveStatuses.All;
var inactive = InactiveStatuses.All;
```

### Custom Return Types

Control the return type of generated methods:

```csharp
public interface IMessage
{
    int Id { get; }
    string Name { get; }
    string GetContent();
}

[EnumCollection(ReturnType = "IMessage")]
public abstract class MessageType : EnhancedEnumBase<MessageType>, IMessage
{
    public abstract string GetContent();
    
    protected MessageType(int id, string name) : base(id, name) { }
}

// Generated methods return IMessage:
IMessage welcome = MessageTypes.Welcome();
```

### Constructor Support

Enhanced Enums support constructors for initialization:

```csharp
[EnumCollection]
public abstract class LogLevel : EnhancedEnumBase<LogLevel>
{
    protected LogLevel(int value, string name) : base(value, name)
    {
        Value = value;
    }
    
    public int Value { get; }
}

[EnumOption]
public class Error : LogLevel
{
    public Error() : base(1, "ERROR") { }
}

[EnumOption]
public class Warning : LogLevel
{
    public Warning() : base(2, "WARN") { }
}
```

### Primary Constructors (C# 12+)

Works seamlessly with primary constructors:

```csharp
[EnumCollection]
public abstract class Size : EnhancedEnumBase<Size>
{
    public int Value { get; }
    
    protected Size(int value, string label) : base(value, label)
    {
        Value = value;
    }
}

[EnumOption]
public class Small : Size
{
    public Small() : base(1, "Small") { }
}

[EnumOption]
public class Medium : Size
{
    public Medium() : base(2, "Medium") { }
}

[EnumOption]
public class Large : Size
{
    public Large() : base(3, "Large") { }
}
```

## Advanced Usage

### Generic Enhanced Enums

Full support for generic base types with type constraints:

```csharp
// Single type parameter
[EnumCollection]
public abstract class Handler<T> : EnhancedEnumBase<Handler<T>>
{
    public abstract void Handle(T item);
    protected Handler(int id, string name) : base(id, name) { }
}

[EnumOption]
public class StringHandler : Handler<string>
{
    public StringHandler() : base(1, "String") { }
    public override void Handle(string item) => Console.WriteLine(item);
}

// Multiple type parameters with constraints
[EnumCollection(DefaultGenericReturnType = "IConverter")]
public abstract class Converter<TInput, TOutput> : EnhancedEnumBase<Converter<TInput, TOutput>>, IConverter
    where TInput : class
    where TOutput : struct
{
    public abstract TOutput Convert(TInput input);
    protected Converter(int id, string name) : base(id, name) { }
}
```

### Factory Method Behavior

Factory methods are generated by default and create **new instances** (not singletons):

```csharp
[EnumCollection]
public abstract class Status : EnhancedEnumBase<Status>
{
    protected Status(int id, string name) : base(id, name) { }
}

[EnumOption]
public class Active : Status
{
    public Active() : base(1, "Active") { }
    public Active(string reason) : base(1, "Active") 
    { 
        Reason = reason; 
    }
    public string? Reason { get; }
}

// Usage:
var instance1 = Statuses.Active();           // new Active()
var instance2 = Statuses.Active("Started");  // new Active("Started")
var singleton = Statuses.GetByName("Active"); // Returns cached singleton
```

#### Disabling Factory Methods

```csharp
// Disable at collection level
[EnumCollection(GenerateFactoryMethods = false)]
public abstract class ConfigOption : EnhancedEnumBase<ConfigOption>
{
    protected ConfigOption(int id, string name) : base(id, name) { }
}

// Disable for specific option
[EnumOption(GenerateFactoryMethod = false)]
public class SpecialConfig : ConfigOption
{
    public SpecialConfig() : base(99, "Special") { }
}
```

When factory methods are disabled, enum options **must** have a public parameterless constructor.

### Case-Sensitive Lookups

```csharp
[EnumCollection(NameComparison = StringComparison.Ordinal)]
public abstract class CaseSensitiveEnum : EnhancedEnumBase<CaseSensitiveEnum>
{
    protected CaseSensitiveEnum(int id, string name) : base(id, name) { }
    // Name lookups will be case-sensitive
}
```

## Performance

Enhanced Enums are optimized for performance:

- **Initialization**: One-time cost during static constructor
- **Factory Methods**: O(1) - Creates new instance quickly
- **Name Lookups**: O(1) - Dictionary lookup (FrozenDictionary on .NET 8+)
- **Property Lookups**: O(1) - Dictionary lookup for single values
- **Memory**: Minimal - Single instance per enum value

### .NET 8+ Optimizations

On .NET 8 or later, the generator uses `FrozenDictionary` for even better performance:
- ~15% faster lookups
- Optimized memory layout
- Better CPU cache utilization

## API Reference

### Attributes

#### `[EnumCollection]`

Marks a type as an enhanced enum base. Applied to abstract classes that inherit from `EnhancedEnumBase<T>`.

**Properties:**
- `CollectionName` (string): Name of the generated collection class. Default: `{TypeName}s`
- `GenerateFactoryMethods` (bool): Generate static factory methods. Default: `true`
- `NameComparison` (StringComparison): How to compare names. Default: `OrdinalIgnoreCase`
- `ReturnType` (string): Return type for generated methods. Default: Base type
- `Namespace` (string): Namespace for the generated collection class. Default: Same as base type

#### `[EnumOption]`

Marks a type as an enum option. Applied to concrete classes that inherit from an enhanced enum base.

**Properties:**
- `Name` (string): Override the display name. Default: Class name
- `CollectionName` (string): Target collection for multiple collection scenarios
- `GenerateFactoryMethod` (bool?): Override factory method generation for this option. Default: null (uses collection setting)

#### `[EnumLookup]`

Generates a lookup method for a property. Applied to properties in the base class.

**Properties:**
- `MethodName` (string): Name of generated method. Default: `GetBy{PropertyName}`
- `AllowMultiple` (bool): Return multiple matches. Default: `false`

### Generated Methods

For an enhanced enum `OrderStatus`, the generator creates `OrderStatuses` with:

```csharp
// Properties
public static ImmutableArray<OrderStatus> All { get; }
public static OrderStatus Empty { get; }

// Factory methods (if enabled) - create new instances
public static OrderStatus Pending() => new Pending();
public static OrderStatus Shipped() => new Shipped();

// Constructor overloads generate method overloads
public static OrderStatus Pending(string reason) => new Pending(reason);

// Lookup methods
public static OrderStatus GetByName(string name);
public static bool TryGetByName(string name, out OrderStatus? value);

// Custom lookups (for [EnumLookup] properties)
public static OrderStatus GetByCode(string code);
public static ImmutableArray<OrderStatus> GetByCategory(string category); // If AllowMultiple
```

## Troubleshooting

### Generator Not Running

1. Ensure both packages are referenced:
   ```xml
   <PackageReference Include="FractalDataWorks.EnhancedEnums" Version="*" />
   <PackageReference Include="FractalDataWorks" Version="*" />
   ```

2. Clean and rebuild your solution

3. Check for compilation errors - generators don't run if there are errors

### Missing Base Class

The base class MUST inherit from `EnhancedEnumBase<T>`:

```csharp
// ❌ Wrong
[EnumCollection]
public abstract class Status
{
    public abstract string Name { get; }
}

// ✅ Correct
[EnumCollection]
public abstract class Status : EnhancedEnumBase<Status>
{
    protected Status(int id, string name) : base(id, name) { }
}
```

### No Empty Value Generated

Ensure your base class has accessible abstract members:

```csharp
[EnumCollection]
public abstract class Status : EnhancedEnumBase<Status>
{
    // Id and Name come from base class
    public abstract string Code { get; }  // ✅ Will be implemented in Empty
    
    public string Description { get; set; }  // ❌ Not abstract, won't be in Empty
    
    protected Status(int id, string name) : base(id, name) { }
}
```

## Complete Feature List

### Core Features

1. **Static Collection Generation**
   - Generates a static class (e.g., `OrderStatuses` for `OrderStatus`)
   - Provides `All` property returning `ImmutableArray<T>`
   - Singleton instances created at static initialization
   - Thread-safe initialization guaranteed

2. **Efficient Lookups**
   - `GetByName(string)` - O(1) dictionary lookup
   - `TryGetByName(string, out T)` - Safe lookup pattern
   - Custom property lookups via `[EnumLookup]` attribute
   - Case-insensitive by default (configurable via `NameComparison`)
   - .NET 8+: Uses `FrozenDictionary` for ~15% better performance

3. **Factory Methods**
   - Generated by default for each enum option
   - Create **new instances** (not singletons)
   - Support constructor overloads automatically
   - Can be disabled globally or per-option
   - Analyzer ENH005 ensures parameterless constructor when disabled

4. **Empty Value Pattern**
   - Every collection has an `Empty` property
   - Returns singleton instance with Id=0, Name="Empty"
   - All abstract properties return appropriate defaults:
     - `string` → `string.Empty`
     - `bool` → `false`
     - `int/long/etc` → `0`
     - Reference types → `null`
   - Abstract methods properly overridden

5. **Generic Type Support**
   - Full support for generic base types
   - Multiple type parameters
   - Type constraints preserved in generated code
   - Automatic namespace resolution
   - `DefaultGenericReturnType` for complex scenarios

6. **Multiple Collections**
   - Create multiple collections from same base type
   - Organize options into logical groups
   - Each collection is independent
   - Options specify target via `CollectionName`

7. **Custom Return Types**
   - Specify interface or base type as return
   - Supports covariance patterns
   - Works with both generic and non-generic types
   - All generated methods use specified return type

8. **C# Language Support**
   - Primary constructor detection (C# 12+)
   - Record type support
   - File-scoped namespaces
   - Nullable reference types
   - Init-only properties

### Code Generation Features

9. **Performance Optimizations**
   - Zero reflection at runtime
   - Compile-time code generation
   - Singleton pattern for zero allocations on lookups
   - Immutable collections prevent modifications
   - Minimal memory footprint

10. **Comprehensive XML Documentation**
    - All generated methods have full XML docs
    - IntelliSense support for all members
    - Parameter descriptions
    - Return value documentation
    - Exception documentation where applicable

11. **Incremental Generation**
    - Only regenerates when source changes
    - Efficient compilation performance
    - Works with hot reload

### Analyzers and Diagnostics

12. **Built-in Analyzers**
    - **ENH001**: Missing EnhancedEnumBase inheritance
    - **ENH002**: Constructor must call base
    - **ENH003**: Cannot be static class
    - **ENH004**: Duplicate enum options detected
    - **ENH005**: Missing parameterless constructor when factory disabled

13. **Code Fixes**
    - Automatic fixes for common issues
    - Add missing base class inheritance
    - Generate required constructors

### Advanced Scenarios

14. **Attribute Configuration**
    - `[EnumCollection]` - Configure collection generation
    - `[EnumOption]` - Mark and configure enum values
    - `[EnumLookup]` - Generate custom lookup methods
    - All attributes support named parameters

15. **Namespace Control**
    - Generate collections in different namespaces
    - Automatic using statement generation
    - Handles nested namespaces correctly

16. **Extensibility**
    - Base class can have additional abstract members
    - Support for methods with parameters
    - Properties can have any type
    - Works with dependency injection patterns

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

### Building from Source

```bash
# Clone the repository
git clone https://github.com/FractalDataWorks/enhanced-enums.git

# Build
dotnet build

# Run tests
dotnet test

# Pack NuGet package
dotnet pack
```

## License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.